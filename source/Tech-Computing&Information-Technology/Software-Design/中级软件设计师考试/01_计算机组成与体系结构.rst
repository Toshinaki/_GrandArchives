
计算机组成与体系结构
=======================

数据的表示
--------------

进制转换
~~~~~~~~~~~~~~


:math:`R` 进制转十进制
^^^^^^^^^^^^^^^^^^^^^^^^^^^

按权展开法:

-  将 :math:`R` 进制数的每一位数值用 :math:`R^k` 的形式表示, :math:`k` 的值以小数点为起点, 小数点左边从 0 开始递增, 右边从 -1 开始递减
-  则 :math:`R` 进制数的十进制为: :math:`\sum{X \times R^k}`, 其中 :math:`X` 为每一位的数值

      二进制转十进制

      :math:`10100.01 = 1 \times 2^4 + 0 \times 2^3 + 1 \times 2^2 + 0 \times 2^{-1} + 1 \times 2^{-2}`


十进制转 :math:`R` 进制
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

短除法:

-  用 :math:`R` 对十进制数连续整除取余直到商为0, 之后将余数反向连接

      :math:`2 \;|\; \underline{94} \qquad \text{余}\;0 \\ 2 \;|\; \underline{47} \qquad \quad\;1\\ 2 \;|\; \underline{23} \qquad \quad\;1\\ 2 \;|\; \underline{11} \qquad \quad\;1\\ 2 \;|\; \underline{5} \qquad \quad\;\;\;1\\ 2 \;|\; \underline{2} \qquad \quad\;\;\;0\\ 2 \;|\; \underline{1} \qquad \quad\;\;\;1\\ \;\;0 \\ \text{其结果为}1011110`

二进制与八进制与十六进制
^^^^^^^^^^^^^^^^^^^^^^^^^^

-  三个二进制位对应一个八进制位
-  四个二进制位对应一个十六进制位

编码
~~~~~~~~~~

原码
^^^^^^^^^^^^

1. 将数转换成二进制
2. 有符号时, 最高位为符号位, 正数为0, 负数为1

反码
^^^^^^^^^^^^

1. 若为正数则不变, 即反码与原码相同
2. 若为负数, 符号位不变, 其他位全部按位取反

补码
^^^^^^^^^^^^

1. 若为正数则不变, 即反码与原码相同
2. 若为负数, 在反码基础上+1

移码
^^^^^^^^^^^^

-  主要用于表示浮点数的阶码，在浮点数运算中有优势
-  在补码的基础上对符号位取反

+------+-----------+-----------+-----------+-----+
|      |     1     |    -1     |    1-1    |     |
+======+===========+===========+===========+=====+
| 原码 | 0000 0001 | 1000 0001 | 1000 0010 | -2  |
+------+-----------+-----------+-----------+-----+
| 反码 | 0000 0001 | 1111 1110 | 1111 1111 | -0  |
+------+-----------+-----------+-----------+-----+
| 补码 | 0000 0001 | 1111 1111 | 0000 0000 | 0   |
+------+-----------+-----------+-----------+-----+
| 移码 | 1000 0001 | 0111 1111 | 1000 0000 |     |
+------+-----------+-----------+-----------+-----+

取值范围
^^^^^^^^^^^^^^^^

+------+----------------------------------------+
| 原码 | :math:`-(2^{n-1}-1) \sim 2^{n-1}`      |
+------+----------------------------------------+
| 反码 | :math:`-(2^{n-1} - 1) \sim 2^{n-1} -1` |
+------+----------------------------------------+
| 补码 | :math:`-2^{n-1} \sim 2^{n-1} -1`       |
+------+----------------------------------------+

浮点数运算
~~~~~~~~~~~~~~~~

即科学计数法:

:math:`N = M * R^e`

运算以最高次指数为准

   :math:`1.0 \times 10^3 + 1.9 \times 10 ^2`

   这种情况下需要将 :math:`1.9 \times 10 ^2` 转换为 :math:`0.19 \times 10 ^3` 再进行运算


计算机结构
--------------

计算机 = 主机 + 外设

.. figure:: imgs/image1.png
   :alt: 计算机结构


Flynn分类法
---------------

+--------------+----------------+----------------------------------------+----------------+
| 体系结构类型 |      结构      |                关键特性                |      代表      |
+==============+================+========================================+================+
| 单指令流     | 控制部分: 一个 | 单处理器系统\                          |                |
| 单数据流     | 处理器: 一个   | (单片机中仍然存在)                     |                |
| SISD         | 主存模块: 一个 |                                        |                |
+--------------+----------------+----------------------------------------+----------------+
| 单指令流     | 控制部分: 一个 | 各处理器以异步的形式执行同一条指令     | 并行处理机     |
| 多数据流     | 处理器: 多个   |                                        | 阵列处理机     |
| SIMD         | 主存模块: 多个 |                                        | 超级向量处理机 |
+--------------+----------------+----------------------------------------+----------------+
| 多指令流     | 控制部分: 多个 | 理论模型                               |                |
| 单数据流     | 处理器: 一个   | 不存在                                 |                |
| MISD         | 主存模块: 多个 |                                        |                |
+--------------+----------------+----------------------------------------+----------------+
| 多指令流     | 控制部分: 多个 | 能够实现作业, 任务, 指令等各级全面并行 | 多处理机系统   |
| 多数据流     | 处理器: 多个   |                                        | 多计算机       |
| MIMD         | 主存模块: 多个 |                                        |                |
+--------------+----------------+----------------------------------------+----------------+

CISIC和RISC
---------------

+--------------+----------------------------------------+------------+-----------------------+------------------+
| 指令系统类型 |                  指令                  |  寻址方式  |       实现方式        |       其他       |
+==============+========================================+============+=======================+==================+
| CISC (复杂)  | 数量多                                 | 支持多种   | 微程序控制技术 (微码) | 研制周期长       |
|              | 使用频率差别大                         |            |                       |                  |
|              | 可变长格式                             |            |                       |                  |
+--------------+----------------------------------------+------------+-----------------------+------------------+
| RISC (精简)  | 数量少                                 | 支持方式少 | 增加了通用寄存器      | 优化编辑         |
|              | 使用频率接近                           |            | 硬布线逻辑控制为主    | 有效支持高级语言 |
|              | 定长格式                               |            | 适合采用流水线        |                  |
|              | 大部分为单周期指令                     |            |                       |                  |
|              | 主要操作寄存器, 只有Load/Store操作内存 |            |                       |                  |
+--------------+----------------------------------------+------------+-----------------------+------------------+


流水线 (Pipelining) 及其计算
--------------------------------

概念
~~~~~~~~~~

   流水线是指程序执行时多条指令重叠进行操作的准并行处理实现技术

   各种部件可同时执行多条指令的不同部分, 以提高各部件的利用率和指令的平均执行速度

.. figure:: imgs/image2.png
   :alt: 流水线

.. figure:: imgs/image3.png
   :alt: 各个部件都有大量的空闲状态

   各个部件都有大量的空闲状态

.. figure:: imgs/image4.png
   :alt: 各个部件充分运行

   各个部件充分运行

执行时长的计算
~~~~~~~~~~~~~~~~~~~~

周期: 执行时间最长的一段

计算公式: :math:`\text{一条指令执行时间} + (\text{指令数} - 1) \times \text{周期}`

-  理论公式: :math:`(t_1 + t_2 + ... + t_k) + (n-1) \times \Delta t`

-  实践公式: :math:`(k + n - 1) \times \Delta t` (将指令执行的每一部分都看作一个周期长)

.. figure:: imgs/image5.png
   :alt: 流水线执行时长

.. admonition:: 例

   若指令流水线把一条指令分为取指 (2ns), 分析 (2ns), 执行(1ns)三部分.

   周期为2ns

   执行100条指令需要用时: :math:`(2+2+1) + (100-1) \times 2 = 203 (或204)`

流水线吞吐率 (Throughput rate)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

流水线在单位时间内执行的任务数或输出的结果数

:math:`TP = \frac{\text{指令数}}{\text{总执行时间}}`

流水线最大吞吐率: :math:`TP_{max} = \lim_{n \right \infty}\frac{n}{(k+n-1)\Delta{t}} = \frac{1}{\Delta{t}}`

流水线的加速比
~~~~~~~~~~~~~~~~~~~~

完成同样一批任务时, 不使用流水线所用时间和使用流水线所用时间之比:

:math:`S = \frac{\text{不使用流水线所用时间}}{\text{使用流水线所用时间}}`

流水线的效率
~~~~~~~~~~~~~~~~~~

流水线的设备利用率,
在时空图上为n个任务占用的时空区与k个流水段的总时空区之比(即 **有效利用的时空区** 占总时空区的比例):

:math:`E = \frac{n\text{个任务占用的时空区}}{k\text{个流水段的总时空区}}`

.. admonition:: 例
   
   设有如下流水线

   周期: :math:`3\Delta t`

   :math:`E = \frac{(\Delta t + \Delta t + \Delta t + 3\Delta t) \times 4}{15\Delta t \times 4}`

.. figure:: imgs/image6.png
   :alt: 例图

由上例可见, 每个流水段用时相同的情况下, 流水线效率最高

层次化存储结构
------------------

.. figure:: imgs/image7.png
   :alt: 层次化存储结构

存储器分类:

-  随机存取存储器RAM (断电后数据丢失)

   -  DRAM (Dynamic RAM, 动态) - 主存
   -  SRAM (Static RAM, 静态) - Cache

-  只读存储器ROM (断电后保存数据, 如BIOS)

   -  MROM (MASK ROM, 掩护式ROM)
   -  PROM (Programmable ROM, 一次可编程ROM)
   -  EPROM (Erasable PROM, 可擦除的PROM)
   -  Flash memory 闪存


高速缓冲存储器 Cache
~~~~~~~~~~~~~~~~~~~~~~~~~~

存在于主存与CPU之间的一级存储器, 由静态存储芯片 (SRAM) 组成, 容量较小但速度比主存高得多

概念
^^^^^^^^^^^^

-  功能: 提高CPU数据输入输出的速率, 突破冯诺依曼瓶颈, 即CPU与存储系统间数据传送带宽限制
-  在存储器中速度仅次于寄存器 (容量极小, 集成在CPU中)
-  Cache基于程序的局部性原理, 得以改善系统性能

命中率
^^^^^^^^^^^^^^^^^^

CPU读取数据时, 会先读取Cache的内容, 如果没有得到目标数据, 再读取内存

CPU读取Cache时获得目标数据的概率称为 **命中率**

若以 :math:`h` 代表Cache的命中率, :math:`t_1` 表示Cache的周期, :math:`t_2` 表示主存储器周期, 以读操作为例, 使用 "Cache + 主存储器" 的系统的_平均周期_为 :math:`t_3`, 则:

.. math::
   t_3 = h\cdot t_1 + (1-h)\cdot t_2

局部性原理
~~~~~~~~~~~~~~~~

在CPU访问寄存器时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理

时间局部性 (temporal locality)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

被引用过一次的存储器位置在未来会被多次引用 (通常在循环中)

.. code:: text

   int s = 0 // 调用一次
   for (i=0; i<1000; i++) // 调用1000000次
       for (j=0; j<1000; j++)
           s += j;
   printf(s) // 调用一次

空间局部性 (spatial locality)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

如果一个存储器的位置被引用, 那么将来他附近的位置也会被引用

工作集理论
^^^^^^^^^^^^^^^^^^

根据程序的局部性理论, Denning提出了工作集理论

所谓工作集是指进程运行时被频繁访问的页面集合

只要使程序的工作集全部集中在内存中, 就可以大大减少进程的缺页次数; 否则会使进程在运行过程中频繁出现缺页中断, 从而出现频繁的页面调入/调出现象, 造成系统性能的下降, 甚至出现 "抖动".

划分工作集可以按 **定长时间** 或 **定长页面** 两种方法进行划分:

-  当颠簸现象发生时, 说明系统的负荷过大, 通常采用处理器均衡调度
-  当缺页率达到上限时, 则增加内存分配量; 当缺页率达到下限时, 就减少内存的分配量

主存储器 Main memory
~~~~~~~~~~~~~~~~~~~~~~~~~~

主存是计算机硬件的一个重要部件, 用于存放指令和数据, 并能由中央处理器(CPU) 直接随机存取

主存储器按地址存放信息的; 存取速度一般与地址无关

编址
^^^^^^^^^^^^

存储器由一块块的空间 (存储单元) 组成, 为了方便找到每个存储单元, 需要对存储单元进行标识, 即 **编址**

-  按字编址

   -  存放一个机器字的存储单元, 通常称为 **字存储单元**
   -  相应的单元地址叫字地址
   -  如果计算机中可编址的最小单位是字存储单元, 则该计算机称为按字编址的计算机

-  按字节编址

   -  存放一个字节的单元, 称为 **字节存储单元**
   -  相应的地址称为字节地址
   -  如果计算机中可编址的最小单 位是字节, 则该计算机称为按字节编址的计算机

**数据总线**: 计算机一次可以处理 :math:`n` 位的数据, 则数据总线的长度为 :math:`n` (数据总线的长度并不一定等于一个地址的长度; 如64位计算机一次可以处理64位数据, 但可以按字节编址即8bit)

**字**: 与数据总线的位数相等 (在64位计算机中, 一个字就是64位)

**容量**:

-  存储器的容量 = 芯片容量 :math:`\times` 芯片个数
-  芯片容量 = 一个地址代表的容量 (即存储单元的大小) :math:`\times` 编址总数 (即存储单元的总数)
-  容量单位通常用字或字节表示 (如64K字, 512KB, 10MB, 即省略存储单元的大小)

**地址总线**: 假如需要 :math:`n` 位二进制数来表示所有的地址，则地址总线的个数为 :math:`n`

.. admonition:: 例1
      
      某存储器只有一个芯片 (8*4bit), 该芯片的容量为32bit; 计算机每次处理4bit数据; 内存按4bit编址:

      则该芯片有 :math:`\text{容量} \div \text{一个地址代表的容量} = 32 \div 4 = 8` 个地址; 数据总线的长度为4; 地址总线的个数为 :math:`\log_2{8} = 3`

.. figure:: imgs/image8.png
   :alt: 例图

.. admonition:: 例2
   
   内存按字节编址, 地址从A4000H到CBFFFH, 则共有 :math:`\text{CBFFFH} + 1 - \text{A4000H} = \text{28000H} = 160K` 字节; 若用存储容量32K :math:`\times` 8 bit 的芯片构成该内存, 则至少需要 :math:`160 \div 32 = 5` 片

磁盘结构与参数
~~~~~~~~~~~~~~~~~~~~